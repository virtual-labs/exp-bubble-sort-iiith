{
    "version": 1,
    "experiment name": "Bubble Sort Implementation",
    "problems": [
        {
            "problem name": "Basic Bubble Sort",
            "description": "Implement the basic Bubble Sort algorithm to sort an array in ascending order. Bubble Sort works by repeatedly stepping through the list, comparing adjacent elements and swapping them if they are in the wrong order.",
            "instructions": [
                "1. Start with the first element of the array",
                "2. Compare it with the next element",
                "3. If the first element is greater than the second, swap them",
                "4. Move to the next pair of elements",
                "5. Repeat steps 2-4 until the end of the array",
                "6. After each pass, the largest element will 'bubble up' to its correct position",
                "7. Repeat the process for the remaining unsorted portion of the array"
            ],
            "input format": {
                "type": "array",
                "description": "An array of integers that needs to be sorted",
                "example": "[64, 66, 20, 49, 11, 79]"
            },
            "output format": {
                "type": "array",
                "description": "The same array sorted in ascending order",
                "example": "[11, 20, 49, 64, 66, 79]"
            },
            "inputs": [
                [64, 66, 20, 49, 11, 79]
            ],
            "expected": [11, 20, 49, 64, 66, 79],
            "difficulty": "beginner",
            "time complexity": "O(n²)",
            "space complexity": "O(1)"
        },
        {
            "problem name": "Optimized Bubble Sort",
            "description": "Implement an optimized version of Bubble Sort that reduces unnecessary comparisons and swaps. The optimization involves tracking whether any swaps occurred in a pass - if no swaps occur, the array is already sorted and we can stop.",
            "instructions": [
                "1. Implement the basic bubble sort algorithm",
                "2. Add a flag to track if any swaps occurred in a pass",
                "3. If no swaps occur in a complete pass, the array is sorted",
                "4. Stop the algorithm when no swaps are needed",
                "5. This optimization is particularly effective for partially sorted arrays"
            ],
            "input format": {
                "type": "array",
                "description": "An array of integers that needs to be sorted",
                "example": "[10, 9, 24, 100, 2, 300, 258, 59]"
            },
            "output format": {
                "type": "array",
                "description": "The same array sorted in ascending order",
                "example": "[2, 9, 10, 24, 59, 100, 258, 300]"
            },
            "inputs": [
                [10, 9, 24, 100, 2, 300, 258, 59]
            ],
            "expected": [2, 9, 10, 24, 59, 100, 258, 300],
            "difficulty": "intermediate",
            "time complexity": {
                "best case": "O(n)",
                "average case": "O(n²)",
                "worst case": "O(n²)"
            },
            "space complexity": "O(1)",
            "optimization tips": [
                "Use a boolean flag to track if any swaps occurred",
                "Reduce the number of comparisons in each pass",
                "Consider the array sorted if no swaps occur in a complete pass"
            ]
        }
    ],
    "evaluation criteria": {
        "correctness": "The solution must correctly sort the input array",
        "efficiency": "The solution should implement the specified algorithm efficiently",
        "code quality": "The code should be well-structured and readable",
        "optimization": "For the second problem, proper implementation of the optimization is required"
    }
}